// Generated by CoffeeScript 1.9.2
(function() {
  'use strict';
  define(['lodash', 'core/util/props', 'core/util/assert'], function(_, props, Assert) {
    return function(initialData) {
      var _first, _index, _last, assertHasKey, createNode, hasKey, injectBefore, injectValue, remove, theList, updateFirstAndLast;
      hasKey = function(value) {
        return (value != null ? value.key : void 0) != null;
      };
      assertHasKey = function(value) {
        Assert["true"](hasKey(value), '\'key\' property not defined');
      };
      _first = void 0;
      _last = void 0;
      _index = {};
      if (initialData != null) {
        _first = initialData.first;
        _last = initialData.last;
        _index = initialData.index;
      }
      theList = {};
      createNode = function(value) {
        var node;
        node = {};
        node.n = void 0;
        node.p = void 0;
        node.v = value;
        return node;
      };
      updateFirstAndLast = function(prev, next) {
        if (_.isEmpty(_index)) {
          return _first = _last = void 0;
        } else {
          if (prev == null) {
            prev = next;
          }
          if ((prev != null ? prev.p : void 0) == null) {
            _first = prev.v.key;
          }
          if (next == null) {
            next = prev;
          }
          if ((next != null ? next.n : void 0) == null) {
            return _last = next.v.key;
          }
        }
      };
      remove = function(node) {
        var next, prev;
        prev = _index[node.p];
        next = _index[node.n];
        if (prev) {
          prev.n = node.n;
        }
        if (next) {
          next.p = node.p;
        }
        node.p = void 0;
        node.n = void 0;
        delete _index[node.v.key];
        updateFirstAndLast(prev, next);
      };
      injectBefore = function(injected, original) {
        var previous;
        Assert["true"](original && injected);
        injected.n = original.v.key;
        injected.p = original.p;
        previous = _index[original.p];
        if (previous) {
          previous.n = injected.v.key;
        }
        original.p = injected.v.key;
        updateFirstAndLast(injected, original);
      };
      injectValue = function(value, nextKey) {
        var next, node;
        assertHasKey(value);
        if (value.key === nextKey) {
          node = _index[value.key];
          node.v = value;
          return;
        }
        node = _index[value.key];
        next = _index[nextKey];
        if (node) {
          remove(node);
          node.v = value;
        } else {
          node = createNode(value);
        }
        if (_first == null) {
          _first = _last = node.v.key;
        } else {
          injectBefore(node, next);
        }
        _index[value.key] = node;
      };
      props(theList, {
        first: {
          get: function() {
            if (_first != null) {
              return this.get(_first);
            }
          }
        },
        last: {
          get: function() {
            if (_last != null) {
              return this.get(_last);
            }
          }
        },
        enqueue: {
          configurable: true,
          value: function(value) {
            injectValue(value, _first);
          }
        },
        dequeue: {
          value: function() {
            var node;
            if (_last == null) {
              return void 0;
            }
            node = _index[_last];
            remove(node);
            return node.v;
          }
        },
        has: {
          value: function(key) {
            return _.has(_index, key);
          }
        },
        get: {
          configurable: true,
          value: function(key) {
            if (_.has(_index, key)) {
              return _index[key].v;
            }
          }
        },
        length: {
          get: function() {
            return _.size(_index);
          }
        },
        toJSON: {
          value: function() {
            return {
              first: _first,
              last: _last,
              index: _index
            };
          }
        },
        clear: {
          value: function() {
            _first = void 0;
            _last = void 0;
            return _index = {};
          }
        }
      });
      return theList;
    };
  });

}).call(this);
